#include "aitype.h"
#include "../fs.h"

#include <iostream>
#include <regex>

const char* AIType::gdf = "aitype.gdf";

AIType::AIType()
{
	for (int i = 0; i < AITYPE_CHARACTERCOUNT; i++)
	{
		this->character[i] = "";
	}

	accuracy = "";
	animTree = "";
	comments = "";
	csvInclude = "";
	engageMaxDist = "";
	engageMaxFalloffDist = "";
	engageMinDist = "";
	engageMinFalloffDist = "";
	grenadeAmmo = "";
	grenadeWeapon = "";
	health = "";
	radiantModel = "";
	secondaryweapon = "";
	sidearm = "";
	team = "";
	type = "";
	weapon = "";
}

AIType::~AIType()
{
}

std::string ExtractStringProperty(std::string prop, std::string _default, std::string src)
{
	std::string out = _default;

	char buf[512] = "";
	sprintf_s(buf, "%s%s%s", "self\\.", prop.c_str(), ".*?\\\"(\\w*)\\\";");
	std::regex ex(buf);// \\\"(\\w+)\\\";");
	std::smatch sm;

	int modelCount = 0;
	while (std::regex_search(src, sm, ex))
	{
		if (sm.size() == 2)
			return sm[1];

		src = sm.suffix().str();
	}

	return out;
}

std::string ExtractRadiantModelProperty(std::string src)
{
	std::string out = "";

	char buf[512] = "";

	std::regex ex("defaultmdl=\\\"(\\w+)\\\".*");
	std::smatch sm;

	int modelCount = 0;
	while (std::regex_search(src, sm, ex))
	{
		if (sm.size() == 2)
			return sm[1];

		src = sm.suffix().str();
	}

	return out;
}

void ExtractCharacterModelProperties(std::string _default, std::string src, std::string* dst, int maxCount)
{
	_ASSERT(dst != NULL);

	std::string out = _default;

	std::regex ex("character\\\\(\\w+)::main");
	std::smatch sm;

	int modelCount = 0;
	while (std::regex_search(src, sm, ex))
	{
		if (sm.size() == 2)
		{
			dst[modelCount++] = sm[1];
			if (modelCount >= maxCount)
			{
				printf("Too many model entries\n");
				return;
			}
		}

		src = sm.suffix().str();
	}
}


std::string ExtractEngagementProperty(std::string prop, std::string _default, std::string src, int arg)
{
	std::string out = _default;

	char buf[512] = "";
	sprintf_s(buf, "%s%s%s", "self\\s+", prop.c_str(), "\\(\\s*(\\d+\\.?\\d+)\\s*,\\s*(\\d+\\.?\\d+)\\s*\\);");
	std::regex ex(buf);
	std::smatch sm;

	int modelCount = 0;
	while (std::regex_search(src, sm, ex))
	{
		if (sm.size() == 3)
			return sm[arg+1];

		src = sm.suffix().str();
	}

	return out;
}

std::string ExtractNumberProperty(std::string prop, std::string _default, std::string src)
{
	std::string out = _default;

	char buf[512] = "";
	sprintf_s(buf, "%s%s%s", "self\\.", prop.c_str(), ".*?(\\d+\\.?\\d+);");
	std::regex ex(buf);// \\\"(\\w+)\\\";");
	std::smatch sm;

	int modelCount = 0;
	while (std::regex_search(src, sm, ex))
	{
		if (sm.size() == 2)
			return sm[1];

		src = sm.suffix().str();
	}

	return out;
}

int AIType::ExtractFromGSC(const char* qpath)
{
	size_t len = FS_FileSize(qpath);
	if (len == -1)
		return -1;

	std::ifstream t(qpath);
	std::string str((std::istreambuf_iterator<char>(t)), std::istreambuf_iterator<char>());

	this->animTree = ExtractStringProperty("animTree", "", str);

	ExtractCharacterModelProperties("", str, this->character, AITYPE_CHARACTERCOUNT);

	this->team = ExtractStringProperty("team", "axis", str);
	this->accuracy = ExtractNumberProperty("accuracy", "0.2", str);
	this->comments = "AutoGenerated by Asset_Util";
	this->csvInclude = ExtractStringProperty("csvInclude", "", str);
	this->engageMaxDist = ExtractEngagementProperty("setEngagementMaxDist", "768", str, 0);
	this->engageMaxFalloffDist = ExtractEngagementProperty("setEngagementMaxDist", "1024", str, 1);
	this->engageMinDist = ExtractEngagementProperty("setEngagementMinDist", "256", str, 0);
	this->engageMinFalloffDist = ExtractEngagementProperty("setEngagementMinDist", "0", str, 1);
	this->grenadeAmmo = ExtractNumberProperty("grenadeAmmo", "0", str);
	this->grenadeWeapon = ExtractStringProperty("grenadeWeapon", "", str);
	this->health = ExtractNumberProperty("health", "100", str);
	this->radiantModel = ExtractRadiantModelProperty(str);
	this->secondaryweapon = ExtractStringProperty("secondaryweapon", "", str);
	this->sidearm = ExtractStringProperty("sidearm", "", str);
	this->type = ExtractStringProperty("type", "human", str);
	this->weapon = ExtractStringProperty("weapon", "", str);

	const char* start = FS_GetFilenameSubString(qpath);
	const char* stop = FS_GetExtensionSubString(qpath);
	this->_name = std::string(start, stop);

	return 0;
}

int AIType::Write(FILE* f)
{
	//
	// Apparently fprintf automatically converts \n to \r\n
	//
	fprintf(f, "\t\"%s\" ( \"%s\" )\n", this->_name.c_str(), this->gdf);
	fprintf(f, "\t{\n");

	fprintf(f, "\t\t\"%s\" \"%s\"\n", "accuracy", this->accuracy.c_str());
	fprintf(f, "\t\t\"%s\" \"%s\"\n", "animTree", this->animTree.c_str());

	for (int i = 0; i < AITYPE_CHARACTERCOUNT; i++)
	{
		fprintf(f, "\t\t\"%s%d\" \"%s\"\n", "character", i + 1, this->character[i].c_str());
	}

	fprintf(f, "\t\t\"%s\" \"%s\"\n", "comments", this->comments.c_str());
	fprintf(f, "\t\t\"%s\" \"%s\"\n", "csvInclude", this->csvInclude.c_str());
	fprintf(f, "\t\t\"%s\" \"%s\"\n", "engageMaxDist", this->engageMaxDist.c_str());
	fprintf(f, "\t\t\"%s\" \"%s\"\n", "engageMaxFalloffDist", this->engageMaxFalloffDist.c_str());
	fprintf(f, "\t\t\"%s\" \"%s\"\n", "engageMinDist", this->engageMinDist.c_str());
	fprintf(f, "\t\t\"%s\" \"%s\"\n", "engageMinFalloffDist", this->engageMinFalloffDist.c_str());
	fprintf(f, "\t\t\"%s\" \"%s\"\n", "grenadeAmmo", this->grenadeAmmo.c_str());
	fprintf(f, "\t\t\"%s\" \"%s\"\n", "grenadeWeapon", this->grenadeWeapon.c_str());
	fprintf(f, "\t\t\"%s\" \"%s\"\n", "health", this->health.c_str());
	fprintf(f, "\t\t\"%s\" \"%s\"\n", "radiantModel", this->radiantModel.c_str());
	fprintf(f, "\t\t\"%s\" \"%s\"\n", "secondaryweapon", this->secondaryweapon.c_str());
	fprintf(f, "\t\t\"%s\" \"%s\"\n", "sidearm", this->sidearm.c_str());
	fprintf(f, "\t\t\"%s\" \"%s\"\n", "team", this->team.c_str());
	fprintf(f, "\t\t\"%s\" \"%s\"\n", "type", this->type.c_str());
	fprintf(f, "\t\t\"%s\" \"%s\"\n", "weapon", this->weapon.c_str());

	fprintf(f, "\t}\n");

	return 0;
}